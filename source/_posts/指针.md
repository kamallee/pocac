title: 指针
date: 2015-08-03 18:45:21
tags: C/C++
categories: C/C++
---
指针引用

要操作内存必须使用指针 
用new创建的都置于堆中
解引用：沿着指针的箭头找到堆（或者其它东西）中的实际值
对于指向结构体的指针，可以先对他进行解引用，然后使用点操作符访问字段
但是箭头操作符一次做两个工作：既对指针解引用，又完成字段访问
使用c++开发项目时先确定使用什么风格的字符串
<!--more-->
引用：会把它当成常亮来使用，不过其本质是原变量的指针， 事实上只是被引用的参数的别名，他们的地址
是相同的即一个地址有两个名称。

const:使用他保护变量
const引用：看似矛盾，引用允许你修改，而const避免修改。但他的意义在于提高效率，如果传递一个引用
，实际上只是传递了原变量的一个指针，这样计算机就无需为之建立副本。const引用两个优势，一来不用
建立副本，二来原变量不会被修改。const可以用于指定函数或方法的参数应该保持不变。
const int *ip;表示不能改变ip指向的值；而int *const ip=NULL;表示不能改变ip这个指针本身。

c++基本设计原则：抽象和重用
c是结构式语言

c++初始化列表：初始化列表会按类定义中数据成员声明的顺序进行初始化，而不是列表中的顺序
指针引用：引用指针的引用，不能声明指向引用的指针

外部链接：对于其他源文件这个名字是可用的；内部链接（也称静态链接）是指对于其他源文件这个名字不
可用。函数和全局变量默认都有外部链接。添加关键字static来制定内部链接。
static可以创建局部变量，只在进入和退出变量作用域之间维护变量的值，比如函数内部定义的变量只能在
函数内部访问。

程序中的全局变量和static类数据成员都是在main()函数运行之前初始化的。

C++中的强制类型转换：dynamic_cast：static转换不会完成运行时的类型检查，而这个会
reinterpret_cast:不同类型的可能也可以转换，可以转换c++理论上不支持的转换（指针->int,int->指针）
const_cast：去除变量的常量性
static_cast：宣示地完成c++支持的转换

作用域解析操作符（::）
全局作用域：(::name，name是一个全局变量）
比如::max(7,i),确认我们调用的是全局名字空间的max(),标准模版库也有一个std::max()模板，在某些情况下
也会被调用，因此有时会产生二义性。

头文件是为子系统或者代码片段提供抽象接口的一种机制
超前引用：即在头文件中放入累的声明，在类定义中就可以使用指向这个类的指针或引用

相对于malloc，new不仅分配空间而且创建对象，使用delete会调用对象的析构函数，free不会
数组即指针，指针并非都是数组
strlen返回的是字符串的长度（不包括'\0')

int calendar[12][31];int (*monthp)[31];monthp=calendar;
monthp指向数组calendar的第一个元素，也就是数组calendar的12个有着31个元素的数组类型元素之一。
int (*monthp)[31]称为数组指针（也称指向一位数组的指针，即行指针），即指向指针的指针。
int *monthp[31];是一个数组指针，即数组里的元素都是指针。

n--==0首先保存n，从n中减去1，然后比较保存值与0的大小
声明与定义：
int a;如果其位置出现在所有函数体之外，那他就被称为外部对象的定义，同时为其分配了空间，并默认初始
化为0
extern int a;并不是a的定义，说明了a是一个外部变量，并且显式地说明了a的存储空间是在程序的其他地方
分配的。
只是对外部变量的引用。 
```{bash}
class Super
{
public:
 void go(){cout<<"go() called on super"< >
 vStack;
```
然而借助于模板的模板参数，你可以只指定容器的类型：Stack vStack;为了获得这个特性，
你必须把第二个参数指定为模板的模板参数，那么声明应该如下:
template class CONT = std::deque >,
本来定义为：template >,CONT是为了定义一个类，
所以只能使用关键字class ,而不能使用typename。只适用于类模板，函数模板不支持模板的模板参数。

类的函数后面加个const，说明该函数不能修改类的成员变量。

缺省构造函数初始化局部变量，例如int x=int();我们将获得缺省值0.模板为：T x=T();
预编译

预编译头文件：即使不存在模板，C++头文件也可以变得非常巨大，从而需要很长的编译时间。模板更是增
加了编译时间。该机制便是为了解决这一问题。我们可以使用某种方式来组织代码，让多个文件中前面的代
码都是相同的，于是我们可以先编译完这N行代码，并把编译在（编译后）这一点的完整状态储存在一个所
谓的预编译头文件中。因此，对于程序中剩下文件的编译我们只需要加载上面已经保存的状态，然后从N+1
行开始变异就可以了（因为前面N行代码都是相同的）。充分利用预处理头文件的关键之处在于：（尽可能的）
确认许多文件开始出的相同代码的最大行数。在实际应用中，这就意味着文件必须以相同的#include指示符开
始，因为#include指示符本身耗费了很大一部分的时间。因此，对于被包含的众多头文件，注意它们被包含顺
序是相当重要的。

SFINAE(substitution-failure-is-not-an-error,替换失败并非错误)：这个原则是令函数模板可以重载的重要原
因。该原则保护的只是：允许试图创建无效的类型，但并不允许试图计算无效的表达式。

当使用到模板的时候，.hpp 中需要包含.cpp文件，否则不能将.cpp 和.hpp 分开编译。
