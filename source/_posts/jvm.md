title: jvm
date: 2015-08-03 18:50:49
tags: java
categories: java
---
Java字节码执行在jre上,jre由java api和jvm组成，jre最重要的部分是jvm，jvm负责分析和执行java字节码。
<!--more-->
<h2>jvm内存划分</h2>
{% img /img/jvmmemory.png jvm内存划分 %}

1.程序计数器是一块较小的内存空间，每个线程启动的时候都会创建一个pc寄存器。当前线程所执行的字节码的行号指示器。线程私有。
2.java栈(方法栈)描述的是java方法执行的内存模型：每个方法被执行都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。线程私有
Sun HotSpot中将java栈和本地方法栈合二为一。线程私有。
3.堆（heap)用于存放对象实例还有数组。是垃圾收集器管理的主要区域，也叫GC堆。线程共享。
4.方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据(Java 虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-
Heap（非堆），目的应该是与Java 堆区分开来)。
{% link http://jbutton.iteye.com/blog/1569737 jvm内存模型 %}
<!--more-->
为什么静态的时全局可访问而非静态的不能？
  非静态方法有一个隐含的传入参数，有JVM在new的时候赋值，这个值就是Stack中的地址指针，该指针指向创建的对象在heap中的地址。静态方法没有这个参数，所以类加载器加载class完成的时候就可以访问改方法而无需new，由于没有隐含指针（该指针指向heap区）所以无法访问heap中的数据。
  安全沙箱机制：
  沙箱的基本组件：1.类加载体系结构2.class文件检验器3.内置于java虚拟机及语言的安全特性4.安全管理器及java API
  前面的三个组件一起保证了虚拟机的实力和它正在运行的应用程序的内部完整性，避免被下载的恶意代码或者有漏洞的代码侵犯。第四个组件保护虚拟机的外部资源不被虚拟机内运行的恶意或有漏洞的代码侵犯。
  虚拟机使用委托双亲的加载模式：启动类加载器可以抢在标准扩展类装载器之前去装载类，而标准扩展类装载器可以抢在类路径加载器之前去装载那个类，类路径装载器又可以抢在自定义类加载器之前去加载它。所以Java虚拟机先从最可信的Java核心API查找类型，这是为了防止不可靠的类扮演被信任的类。（参考：http://cantellow.iteye.com/blog/355049）
JVM在下面几种不同的层面使用不同的类加载器：
bootstrap class loader（引导类加载器）：是其他类加载器的父类，它用于加载Java核心库，并且是唯一一个用本地代码编写的类加载器。
extension class loader（扩展类加载器）：是bootstrap class loader加载器的子类，用于加载扩展库。
system class loader（系统类加载器）：是extension class loader加载器的子类，用于加载在classpath中的应用程序的类文件。
user-defined class loader（用户定义的类加载器）：是系统类加载器或其他用户定义的类加载器的子类。
当一个类加载器收到一个加载类的请求，首先它会检查缓存，确认该类是否已经被加载，然后把请求代理给它的父类。如果父类没能成功的加载类，那么子类就会自己去尝试加载该类。子类可检查父类加载器的缓存，但父类不能看到子类所加载的类。之所类加载体系会这样设计，是认为一个子类不应该重复加载已经被父类加载过的类。
{% img /img/jvmgeneration.png jvm分代内存模型 %}
年轻代：
所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
JVM使用的是分代垃圾回收的方式，主要是因为在程序运行的时候会有如下特点：
◆大多数对象在创建后很快就没有对象使用它了。
◆大多数在一直被使用的对象很少再去引用新创建的对象。

"新生代"区域中，绝大多数新创建的对象都存放在这个区域里，此区域一般来说较小而且JVM垃圾回收频率较高，同时因为"新生代"采用的算法和其存放的对象的特点，使该区域JVM垃圾回收的效率也非常高。("新生代"区域设置参数是"-Xmn"，用这个参数可以制定"新生代"区域的大小)

满足下面条件，方法区的class定义所占内存将被回收
class所有的实例均被回收。
class的classloader被回收。
class没有再被引用，以免使用reflect被初始化。
JVM启动参数 -Xnoclassgc 表示不对方法区进行垃圾回收。请谨慎使用。方法区垃圾回收到此结束。

{% img /img/jvmgc.png jvm垃圾回收模型 %}

<h2>回收算法</h2>

简单的说，如果一个实例没有再被使用，则可以当作垃圾被回收。如何判断实例是否被引用？通过根搜索，从GC roots开始，如果能找到实例，则实例还在被使用，如果找不到，则实例就已经死去。

GC roots可以是：

栈中reference
方法区中的reference
Java中对reference又分4类：

强引用，不能回收
软引用，第一次GC发生时，不回收，第二次回收
弱引用，回收
虚引用，回收 （虚引用我们接触不到，它是JVM用于接收垃圾回收后发送事件）。
新生代与老生代

堆中实例又被分为新生代和老生代。简单的理解，新生代是生命周期短，朝生夕死的实例，GC发生时新生代的成活率不足10%。老生代是一旦生成，就很难死去的实例。它们的成活率能占到近2/3.

新生代向老生代转变的几个条件：

新生代超过N次GC都没被回收，将变为老生代。N可以通过JVM参数指定，-XX:MaxTenuringThreshold=N. Parallel收集器默认是15.
如果实例需要的内存大小超过M,则直接分配到老生代。 M可以通过JVM参数指定。-XX:PretenureSizeThreshold=M。
如果suvivor中 同一代的实例在占据了survivor区（稍后讲）的一半以上，则年龄大于等于此代的一同进入老生代。
Minor GC时，Survivor无法容纳存活新生代，由老生代空间担保，新生代被挪入老生代。

而"老生代"区域中存放的是在"新生代"中生存了较长时间的对象，这些对象将被转移到"老生代"区。这个区域一般要大一些而且增长的速度相对于"新生代"要慢一些，"老生代"JVM垃圾回收的执行频率也会低很多。

perm方法区
也被成为持久代，用来存放JVM加载的类型信息。包括: 类型基本信息，常量池，字段信息，方法信息，类变量，指向ClassLoader的引用，Class类的引用，方法表等。方法区是全局共享的，在一定条件下也会被GC。
相关参数：
-XX:PermSize --设置Perm区的初始大小
-XX:MaxPermSize --设置Perm区的最大值
<h2>回收算法大体3类</h2>
1.标记-清除  顾名思义，就是将还在用的实例进行标记，然后将没标记的内存全部释放掉。 缺点是这将导致不连续的内存碎片，使得后面无法进行大块内存分配，从而导致再次出发GC。 老生代收集器CMS使用的算法。碎片也是CMS收集器的巨大缺点。
2.复制    新生代所使用的算法。新生代的内存分成3块，Eden和2个survivor. 因为大部分新生代成活率不到10%，所以，使用复制算法，将存活的实例复制到其中一个空白的survivor上，然后释放eden和另一个survivor的内存。两个survivor交替使用。上次GC用你，下次GC用我。默认情况下，Eden的大小是一个survivor大小的8倍。两个survivor相等。所以一个survivor占新生代内存的10%。 使用-XX:SurvivorRatio=8来改变eden与survivor的比例。
3.标记-整理  老生代经常使用的算法。和清除不同，将标记存活的实例向前移动，使得它们在内存上是存放连续的。

<h2>堆内存分配策略与GC触发</h2>

堆的大小由下面参数决定。
-Xms 堆最小值， -Xmx 堆最大值。

堆的大小动态调整
-XX:MaxHeapFreeRatio=70 当堆剩余空间达到70%，堆将变为Xms最小值。
-XX:MinHeapFreeRatio=40 当堆剩余空间低于到40%，堆将变成Xmx最大值。

堆分新生代和老生代。
-Xmn 为新生代大小。也可以用-XX:NewRatio=2来分配New/Old的比例。 2为默认值。

新生代又划分Eden和2*survivor。
-XX:survivorRatio=8来规定Eden/survivor的比例。8为默认值。
实例首先尝试分配在新生代eden上。如果实例所占内存超出限制XX:PretenureSizeThreshold，则直接分配到老生代。新生代分配内存时，如果eden空间不足，则触发新生代的GC， minor GC。老生代分配内存时，如果空间不足，则触发老生代的GC， full GC。老生代的GC比新生代GC要慢很多倍。老生代GC频率也比新生代低。
具体执行过程：
1.绝大多数新创建的对象分配在Eden区。
2.在Eden区发生一次GC后，存活的对象移到其中一个Survivor区。
3.在Eden区发生一次GC后，对象是存放到Survivor区，这个Survivor区已经存在其他存活的对象。
4.一旦一个Survivor区已满，存活的对象移动到另外一个Survivor区(可以看出其中一个Survivor区必须保持空)。然后之前那个空间已满Survivor区将置为空，没有任何数据。
5.经过重复多次这样的步骤后依旧存活的对象将被移到老年代。

新生代minor GC(在年轻代Young space(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC)时，如果存活的空间survivor容纳不下，则需要用老生代空间担保。如果老生代也容纳不下，就需要老生代做一次Full GC。 JVM会计算以往minor GC时新生代晋升老生代的平均大小，如果平均大小大于老生代剩余空间，则有很大可能发生担保失败，所以在minor GC前，先触发一次Full GC. 如果小于，则查看是否允许担保失败，如果允许，就直接进行minor GC。不允许，则先Full GC，再minor GC。

-XX:+HandlePromotionFailure 是允许老生代担保失败的发生。每次minor GC前，都会检查老生代剩余空间。JVM会计算以往minor GC时新生代晋升老生代的平均大小。此参数用于当平均大小小于老生代剩余空间时。以往小于不代表这次也小于，风险还是存在。如果允许担保失败，则直接进行minor GC, minor GC失败后，再Full GC. 如果不允许担保失败，则必须先运行Full GC，再minor GC。

这样子新生代GC时，如果survivor无法容纳存活实例，则将部分复制到老生代担保中。

<h2>垃圾回收器</h2>
Serial : 新生代收集器，使用copy算法。特点是单线程，当GC运行时，stop the world，所有的用户线程都必须暂停，等GC完成。缺点是停顿时间太长。

ParNew: 新生代收集器，使用copy，特点是多线程，也是停止用户线程，GC以后再运行用户线程。

Parallel: 新生代收集器，使用copy，但它注重JVM的吞吐量(JVM运行用户线程时间/GC线程时间），在提高吞吐量上有非常好的性能。它提供了很多可控参数，帮助调节JVM的吞吐量和停顿时间。

Serial Old: 老生代收集器，使用标记整理算法，特点跟serial 一样。

Parallel Old:老生代收集器，使用标记整理，产生于JDK 1.6，和Parallel搭配。在之前，Parallel只能和Serial old搭配，总体性能不是特别理想，现在双P。

CMS(Concurrent Mark Sweep）：老生代收集器，使用标记清除。它的特点是可以和用户线程并发，可以减小停顿时间，但牺牲了吞吐量。CMS不能和Parallel搭配，一半和ParNew搭配。CMS的并发特性导致它3大缺点，1）对CPU要求高，2）无法清除因并发产生的浮动垃圾，3）容易产生碎片，为了清理碎片，每几次CMS之后，可以使用参数控制是否进行空间压缩。由于CMS是并发的，CMS需要预留空间给用户线程，一半老生代空间达到68%，就启动CMS. CMS过程中一旦程序失败，则发生CMS error。然后将使用Serial old作为它的备选，重新收集。CMS三个参数：

XX:CMSInitiatingOccupancyFaction  设置老年代空间使用多少后出发CMS垃圾收集。一般是68%
XX:UseCMSCompactAtFullCollection 每次CMS Full GC以后，做一次碎片整理。
XX:CMSFullGCsBeforeCompaction 规定在多少次CMS Full GC以后，做一次碎片整理。
G1，传说中的新收集器，可以指定停顿时间，更高的效率。

Serial 和 serial old适合Client端的JVM。
Server端常用的是Parallel + Parallel Old, ParNew + CMS.
Parallel + Parallel Old 的吞吐量高
ParNew + CMS可减小停顿时间。
